# Template to produce a new OpenShift pipeline job for polling for Pagure branches or PRs
#
---
apiVersion: v1
kind: Template
metadata:
  name: waiverdb-polling-to-pagure
labels:
  template: waiverdb-polling-to-pagure
parameters:
- name: NAME
  displayName: Short unique identifier for the templated instances
  description: This field is used to deploy multiple pipelines to one OpenShift project from this template.
  required: true
  value: waiverdb-polling-to-pagure
- name: PAGURE_REPO_NAME
  displayName: Pagure project name
  description: <username>/<namespace>/<repo>
  required: true
  value: waiverdb
- name: PAGURE_REPO_IS_FORK
  displayName: Is the Pagure repo a fork?
  required: true
  value: "false"
- name: PAGURE_POLLING_FOR_PR
  displayName: set to 'true' to poll for PRs, or 'false' for the master branch
  required: true
  value: "false"
- name: PAGURE_POLLING_SCHEDULE
  displayName: Schedule of polling
  description: using cron-style syntax
  required: true
  value: "H/5 * * * *"
- name: PAGURE_POLLED_BRANCH
  displayName: Name of polled branch
  required: true
  value: "master"
- name: DEV_PIPELINE_BC_NAME
  displayName: Name of BuildConfig for starting dev pipeline builds
  required: true
  value: waiverdb-dev
- name: DEV_PIPELINE_BC_NAMESPACE
  displayName: Namespace of BuildConfig for starting dev pipeline builds
  required: false
- name: PAGURE_API_KEY_SECRET_NAME
  displayName: Name of Secret for updating Pagure pull-requests status
  value: 'pagure-api-key'
  required: false
- name: MAIL_ENABLED
  displayName: Whether to send an email
  value: 'true'
  required: true
- name: JENKINS_AGENT_IMAGE
  displayName: Container image for Jenkins slave pods
  required: true
  value: docker-registry.engineering.redhat.com/factory2/waiverdb-jenkins-slave:latest
- name: OPENSHIFT_CLOUD_NAME
  displayName: Name of OpenShift cloud in Jenkins master configuration
  required: true
  value: openshift
objects:
- kind: ServiceAccount
  apiVersion: v1
  metadata:
    name: "${NAME}-jenkins-slave"
    labels:
      app: "${NAME}"
- kind: RoleBinding
  apiVersion: v1
  metadata:
    name: "${NAME}-jenkins-slave_edit"
    labels:
      app: "${NAME}"
  subjects:
  - kind: ServiceAccount
    name: "${NAME}-jenkins-slave"
  roleRef:
    name: edit
- kind: "BuildConfig"
  apiVersion: "v1"
  metadata:
    name: "${NAME}"
    labels:
      app: "${NAME}"
  spec:
    runPolicy: "Serial"
    strategy:
      type: JenkinsPipeline
      jenkinsPipelineStrategy:
        jenkinsfile: |-
          // Don't use external Jenkinsfile here, or Jenkins will also poll on that repo and branch
          pipeline {
            agent {
              kubernetes {
                cloud "${OPENSHIFT_CLOUD_NAME}"
                label "jenkins-slave-${UUID.randomUUID().toString()}"
                serviceAccount "${NAME}-jenkins-slave"
                defaultContainer 'jnlp'
                yaml """
                apiVersion: v1
                kind: Pod
                metadata:
                  labels:
                    app: "jenkins-${env.JOB_BASE_NAME}"
                    factory2-pipeline-kind: "waiverdb-polling-to-pagure-pipeline"
                    factory2-pipeline-build-number: "${env.BUILD_NUMBER}"
                spec:
                  containers:
                  - name: jnlp
                    image: "${JENKINS_AGENT_IMAGE}"
                    imagePullPolicy: Always
                    tty: true
                    resources:
                      requests:
                        memory: 378Mi
                        cpu: 200m
                      limits:
                        memory: 768Mi
                        cpu: 500m
                """
              }
            }
            options {
              timestamps()
            }
            environment {
              PIPELINE_NAMESPACE = readFile('/run/secrets/kubernetes.io/serviceaccount/namespace').trim()
              PAGURE_URL = 'https://pagure.io'
              PAGURE_API = "${env.PAGURE_URL}/api/0"
              PAGURE_REPO_IS_FORK = "${PAGURE_REPO_IS_FORK}"
              PAGURE_POLLING_FOR_PR = "${PAGURE_POLLING_FOR_PR}"
              PAGURE_REPO_HOME = "${env.PAGURE_URL}${env.PAGURE_REPO_IS_FORK == 'true' ? '/fork' : ''}/${PAGURE_REPO_NAME}"
              GIT_URL = "${env.PAGURE_URL}/${env.PAGURE_REPO_IS_FORK == 'true' ? 'forks/' : ''}${PAGURE_REPO_NAME}.git"
            }
            triggers { pollSCM("${PAGURE_POLLING_SCHEDULE}") }
            stages {
              stage('Prepare') {
                agent { label 'master' }
                steps {
                  script {
                    // checking out the polled branch
                    def polledBranch = env.PAGURE_POLLING_FOR_PR == 'true' ? 'origin/pull/*/head' : "origin/${PAGURE_POLLED_BRANCH}"
                    def scmVars = checkout([$class: 'GitSCM',
                      branches: [[name: polledBranch]],
                      userRemoteConfigs: [
                        [
                          name: 'origin',
                          url: env.GIT_URL,
                          refspec: '+refs/heads/*:refs/remotes/origin/* +refs/pull/*/head:refs/remotes/origin/pull/*/head',
                        ],
                      ],
                      extensions: [[$class: 'CleanBeforeCheckout']],
                    ])
                    env.GIT_COMMIT = scmVars.GIT_COMMIT
                    env.GIT_AUTHOR_EMAIL = scmVars.GIT_AUTHOR_EMAIL
                    // setting build display name
                    def prefix = 'origin/'
                    def branch = scmVars.GIT_BRANCH.startsWith(prefix) ? scmVars.GIT_BRANCH.substring(prefix.size())
                      : scmVars.GIT_BRANCH // origin/pull/1234/head -> pull/1234/head, origin/master -> master
                    env.GIT_BRANCH = branch
                    echo "Build on branch=${env.GIT_BRANCH}, commit=${env.GIT_COMMIT}"
                    if (env.PAGURE_POLLING_FOR_PR == 'false' && branch == "${PAGURE_POLLED_BRANCH}") {
                      echo 'Building master'
                      currentBuild.displayName = "${PAGURE_POLLED_BRANCH}"
                    }
                    else if (env.PAGURE_POLLING_FOR_PR == 'true' && branch ==~ /^pull\/[0-9]+\/head$/) {
                      env.PR_NO = branch.split('/')[1]
                      env.PR_URL = "${env.PAGURE_REPO_HOME}/pull-request/${env.PR_NO}"
                      // To HTML syntax in build description, go to `Jenkins/Global Security/Markup Formatter` and select 'Safe HTML'.
                      def pagureLink = """<a href="${env.PR_URL}">PR-${env.PR_NO}</a>"""
                      try {
                        def prInfo = getPagurePRInfo()
                        pagureLink = """<a href="${env.PR_URL}">${prInfo.title}</a>"""
                      } catch (Exception e) {
                        echo "Error using pagure API: ${e}"
                        // ignoring this...
                      }
                      echo "Building PR #${env.PR_NO}: ${env.PR_URL}"
                      // FIXME: We are going to pass the display name to the triggered dev pipeline build,
                      // however OpenShift Pipeline DSL is buggy to handle arguments with special bash characters (like whitespaces, #, etc).
                      // https://bugzilla.redhat.com/show_bug.cgi?id=1625518
                      currentBuild.displayName = "PR-${env.PR_NO}"
                      currentBuild.description = pagureLink
                    } else { // This shouldn't happen.
                      error("Build is aborted due to unexpected polling trigger actions.")
                    }
                  }
                }
              }
              stage('Run Dev Build') {
                steps {
                  script {
                    openshift.withCluster() {
                      openshift.withProject("${DEV_PIPELINE_BC_NAMESPACE}") {
                        def bcSelector = openshift.selector('bc', "${DEV_PIPELINE_BC_NAME}")
                        echo 'Starting a dev pipeline build...'
                        def isMaster = env.PAGURE_POLLING_FOR_PR != 'true'
                        def devBuild = bcSelector.startBuild(
                          '-e', "WAIVERDB_GIT_REPO=${env.GIT_URL}",
                          '-e', "WAIVERDB_GIT_REF=${env.GIT_BRANCH}",
                          '-e', "FORCE_PUBLISH_IMAGE=${isMaster}",
                          '-e', "FORCE_PUBLISH_DOCS=${isMaster}",
                          '-e', "WAIVERDB_MAIN_BRANCH=${PAGURE_POLLED_BRANCH}",
                          '-e', "BUILD_DISPLAY_RENAME_TO=${currentBuild.displayName}",
                        )
                        devBuild.watch {
                          return !(it.object().status.phase in ["New", "Pending"])
                        }
                        def devBuildInfo = devBuild.object()
                        env.DEV_BUILD_URL = devBuildInfo.metadata.annotations['openshift.io/jenkins-build-uri'] ?: env.BUILD_URL
                        echo "Waiting for dev build ${devBuildInfo.metadata.name}(${env.DEV_BUILD_URL}) to complete..."
                        devBuild.watch {
                          return it.object().status.phase != "Running"
                        }
                        devBuildInfo = devBuild.object()
                        echo "Dev build ${devBuildInfo.metadata.name}(${env.DEV_BUILD_URL}) finished with status ${devBuildInfo.status.phase}."
                        if (devBuildInfo.status.phase != "Complete") {
                          error("Dev build ${devBuildInfo.metadata.name}(${env.DEV_BUILD_URL}) failed.")
                        }
                      }
                    }
                  }
                }
              }
            }
            post {
              success {
                script {
                  // updating Pagure PR flag
                  if (env.PAGURE_POLLING_FOR_PR == 'true' && "${PAGURE_API_KEY_SECRET_NAME}") {
                    try {
                      setBuildStatusOnPagurePR(100, 'Build passed.')
                      echo "Updated PR #${env.PR_NO} status to PASS."
                    } catch (e) {
                      echo "Error updating PR #${env.PR_NO} status to PASS: ${e}"
                    }
                  }
                  // sending email
                  if ("${MAIL_ENABLED}" == 'true' && env.PAGURE_POLLING_FOR_PR == 'true'){
                    try {
                      sendBuildStatusEmail(true)
                    } catch (e) {
                      echo "Error sending email: ${e}"
                    }
                  }
                }
              }
              failure {
                script {
                  // updating Pagure PR flag
                  if (env.PAGURE_POLLING_FOR_PR == 'true' && "${PAGURE_API_KEY_SECRET_NAME}") {
                    try {
                      setBuildStatusOnPagurePR(0, 'Build failed.')
                      echo "Updated PR #${env.PR_NO} status to FAILURE."
                    } catch (e) {
                      echo "Error updating PR #${env.PR_NO} status to FAILURE: ${e}"
                    }
                  }
                  // sending email
                  if ("${MAIL_ENABLED}" == 'true'){
                    try {
                      sendBuildStatusEmail(false)
                    } catch (e) {
                      echo "Error sending email: ${e}"
                    }
                  }
                }
              }
            }
          }
          import java.net.URLEncoder
          class PagureClient {
            String pagureApiUrl
            String token
            def steps
            def callApi(String httpMode, String apiPath, Map payload = null) {
              def headers = []
              if (token) {
                headers << [name: 'Authorization', value: "token ${token}", maskValue: true]
              }
              def payloadItems = []
              if (payload) {
                payloadItems = payload.collect {
                  URLEncoder.encode(it.key.toString(), 'utf-8') +
                  '=' +  URLEncoder.encode(it.value.toString(), 'utf-8')
                }
              }
              return steps.httpRequest(
                  httpMode: httpMode,
                  url: "${pagureApiUrl}/${apiPath}",
                  acceptType: 'APPLICATION_JSON',
                  contentType: 'APPLICATION_FORM',
                  requestBody: payloadItems.join('&'),
                  customHeaders: headers,
                )
            }
            def getPR(Map args) {
              def apiPath = "${args.fork?'fork/':''}${args.repo}/pull-request/${args.pr}"
              def response = callApi('GET', apiPath)
              return steps.readJSON(text: response.content)
            }
            def updatePRStatus(Map args) {
              def apiPath = "${args.fork?'fork/':''}${args.repo}/pull-request/${args.pr}/flag"
              def response = callApi('POST', apiPath, [
                'username': args.username,
                'uid': args.uid,
                'percent': args.percent,
                'comment': args.comment,
                'url': args.url,
              ])
              return steps.readJSON(text: response.content)
            }
          }
          def getPagurePRInfo() {
            def pagureClient = new PagureClient (pagureApiUrl: env.PAGURE_API, steps: steps)
            return pagureClient.getPR(fork: env.PAGURE_REPO_IS_FORK == 'true', repo: "${PAGURE_REPO_NAME}", pr: env.PR_NO)
          }
          def setBuildStatusOnPagurePR(int percent, String comment) {
            withCredentials([string(credentialsId: "${env.PIPELINE_NAMESPACE}-${PAGURE_API_KEY_SECRET_NAME}", variable: 'TOKEN')]) {
              def pagureClient = new PagureClient (pagureApiUrl: env.PAGURE_API, token: env.TOKEN, steps: steps)
              pagureClient.updatePRStatus(
                username: 'c3i-jenkins', uid: 'ci-pre-merge', url: env.DEV_BUILD_URL,
                percent: percent, comment: comment, pr: env.PR_NO,
                repo: "${PAGURE_REPO_NAME}", fork: env.PAGURE_REPO_IS_FORK == 'true')
            }
          }
          def sendBuildStatusEmail(boolean success) {
            def status = success ? 'passed' : 'failed'
            def reciepent = env.PAGURE_POLLING_FOR_PR != 'true' && ownership.job.ownershipEnabled && ownership.job.primaryOwnerEmail ?
              ownership.job.primaryOwnerEmail : env.GIT_AUTHOR_EMAIL
            def subject = "Jenkins job ${env.JOB_NAME} #${env.BUILD_NUMBER} ${status}."
            def body = "Build URL: ${env.DEV_BUILD_URL}"
            if (env.PAGURE_POLLING_FOR_PR == 'true') {
              subject = "Jenkins job ${env.JOB_NAME}, PR #${env.PR_NO} ${status}."
              body += "\nPull Request: ${env.PR_URL}"
            }
            emailext to: reciepent, subject: subject, body: body
          }
